# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class CompanyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Company]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Company.prisma().query_raw(
            'SELECT * FROM Company WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Company
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Company.prisma().query_first(
            'SELECT * FROM Company WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CompanyCreateInput,
        include: Optional[types.CompanyInclude] = None
    ) -> _PrismaModelT:
        """Create a new Company record.

        Parameters
        ----------
        data
            Company record data
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The created Company record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Company record from just the required fields
        company = await Company.prisma().create(
            data={
                # data to create a Company record
                'name': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CompanyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Company records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Company record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Company.prisma().create_many(
            data=[
                {
                    # data to create a Company record
                    'name': 'bbehjachib',
                },
                {
                    # data to create a Company record
                    'name': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Company record.

        Parameters
        ----------
        where
            Company filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The deleted Company record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().delete(
            where={
                'id': 'dgiiaaijj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Company record.

        Parameters
        ----------
        where
            Company filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The found Company record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().find_unique(
            where={
                'id': 'bfaiacjjfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Company record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Company filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The found Company record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().find_unique_or_raise(
            where={
                'id': 'eigcfgbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Company records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Company records returned
        skip
            Ignore the first N results
        where
            Company filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Company]
            The list of all Company records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Company records
        companys = await Company.prisma().find_many(take=10)

        # find the first 5 Company records ordered by the createdAt field
        companys = await Company.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Company record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Company filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Company
            The first Company record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Company record ordered by the credits field
        company = await Company.prisma().find_first(
            skip=1,
            order={
                'credits': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Company record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Company filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Company
            The first Company record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Company record ordered by the tag field
        company = await Company.prisma().find_first_or_raise(
            skip=1,
            order={
                'tag': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CompanyUpdateInput,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Company record.

        Parameters
        ----------
        data
            Company record data specifying what to update
        where
            Company filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The updated Company record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        company = await Company.prisma().update(
            where={
                'id': 'bagcfbhiig',
            },
            data={
                # data to update the Company record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CompanyWhereUniqueInput,
        data: types.CompanyUpsertInput,
        include: Optional[types.CompanyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Company filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The created or updated Company record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().upsert(
            where={
                'id': 'cghideieh',
            },
            data={
                'create': {
                    'id': 'cghideieh',
                    'name': 'cadfabfehe',
                },
                'update': {
                    'name': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CompanyUpdateManyMutationInput,
        where: types.CompanyWhereInput,
    ) -> int:
        """Update multiple Company records

        Parameters
        ----------
        data
            Company data to update the selected Company records to
        where
            Filter to select the Company records to update

        Returns
        -------
        int
            The total number of Company records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Company records
        total = await Company.prisma().update_many(
            data={
                'id': 'biabhbdai'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Company records present in the database

        Parameters
        ----------
        select
            Select the Company fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Company filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Company.prisma().count()

        # results: prisma.types.CompanyCountAggregateOutput
        results = await Company.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CompanyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> types.CompanyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CompanyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> Union[int, types.CompanyCountAggregateOutput]:
        """Count the number of Company records present in the database

        Parameters
        ----------
        select
            Select the Company fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Company filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Company.prisma().count()

        # results: prisma.types.CompanyCountAggregateOutput
        results = await Company.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CompanyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CompanyWhereInput] = None
    ) -> int:
        """Delete multiple Company records.

        Parameters
        ----------
        where
            Optional Company filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Company records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Company records
        total = await Company.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CompanyScalarFieldKeys'],
        *,
        where: Optional['types.CompanyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CompanyAvgAggregateInput'] = None,
        sum: Optional['types.CompanySumAggregateInput'] = None,
        min: Optional['types.CompanyMinAggregateInput'] = None,
        max: Optional['types.CompanyMaxAggregateInput'] = None,
        having: Optional['types.CompanyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CompanyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CompanyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CompanyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CompanyGroupByOutput']:
        """Group Company records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Company fields to group records by
        where
            Company filter to select records
        take
            Limit the maximum number of Company records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CompanyGroupByOutput]
            A list of dictionaries representing the Company record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Company records by credits values
        # and count how many records are in each group
        results = await Company.prisma().group_by(
            ['credits'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlanActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Plan]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Plan.prisma().query_raw(
            'SELECT * FROM Plan WHERE id = $1',
            'idghgaicb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Plan
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Plan.prisma().query_first(
            'SELECT * FROM Plan WHERE companyId = $1',
            'fjfddhigg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlanCreateInput,
        include: Optional[types.PlanInclude] = None
    ) -> _PrismaModelT:
        """Create a new Plan record.

        Parameters
        ----------
        data
            Plan record data
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The created Plan record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Plan record from just the required fields
        plan = await Plan.prisma().create(
            data={
                # data to create a Plan record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlanCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Plan records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Plan record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Plan.prisma().create_many(
            data=[
                {
                    # data to create a Plan record
                },
                {
                    # data to create a Plan record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlanWhereUniqueInput,
        include: Optional[types.PlanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Plan record.

        Parameters
        ----------
        where
            Plan filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The deleted Plan record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plan = await Plan.prisma().delete(
            where={
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlanWhereUniqueInput,
        include: Optional[types.PlanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Plan record.

        Parameters
        ----------
        where
            Plan filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The found Plan record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plan = await Plan.prisma().find_unique(
            where={
                'id': 'cbbbjbfcii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlanWhereUniqueInput,
        include: Optional[types.PlanInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Plan record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Plan filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The found Plan record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plan = await Plan.prisma().find_unique_or_raise(
            where={
                'id': 'bbejhfidcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
        include: Optional[types.PlanInclude] = None,
        order: Optional[Union[types.PlanOrderByInput, List[types.PlanOrderByInput]]] = None,
        distinct: Optional[List[types.PlanScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Plan records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Plan records returned
        skip
            Ignore the first N results
        where
            Plan filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plan model
        order
            Order the returned Plan records by any field
        distinct
            Filter Plan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Plan]
            The list of all Plan records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Plan records
        plans = await Plan.prisma().find_many(take=10)

        # find the first 5 Plan records ordered by the seats field
        plans = await Plan.prisma().find_many(
            take=5,
            order={
                'seats': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
        include: Optional[types.PlanInclude] = None,
        order: Optional[Union[types.PlanOrderByInput, List[types.PlanOrderByInput]]] = None,
        distinct: Optional[List[types.PlanScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Plan record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Plan filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plan model
        order
            Order the returned Plan records by any field
        distinct
            Filter Plan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Plan
            The first Plan record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Plan record ordered by the startedWithCredits field
        plan = await Plan.prisma().find_first(
            skip=1,
            order={
                'startedWithCredits': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
        include: Optional[types.PlanInclude] = None,
        order: Optional[Union[types.PlanOrderByInput, List[types.PlanOrderByInput]]] = None,
        distinct: Optional[List[types.PlanScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Plan record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Plan filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plan model
        order
            Order the returned Plan records by any field
        distinct
            Filter Plan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Plan
            The first Plan record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Plan record ordered by the startedWithSeats field
        plan = await Plan.prisma().find_first_or_raise(
            skip=1,
            order={
                'startedWithSeats': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlanUpdateInput,
        where: types.PlanWhereUniqueInput,
        include: Optional[types.PlanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Plan record.

        Parameters
        ----------
        data
            Plan record data specifying what to update
        where
            Plan filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The updated Plan record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        plan = await Plan.prisma().update(
            where={
                'id': 'bgeecijdgg',
            },
            data={
                # data to update the Plan record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlanWhereUniqueInput,
        data: types.PlanUpsertInput,
        include: Optional[types.PlanInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Plan filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The created or updated Plan record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plan = await Plan.prisma().upsert(
            where={
                'id': 'bdiicjafbj',
            },
            data={
                'create': {
                    'id': 'bdiicjafbj',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlanUpdateManyMutationInput,
        where: types.PlanWhereInput,
    ) -> int:
        """Update multiple Plan records

        Parameters
        ----------
        data
            Plan data to update the selected Plan records to
        where
            Filter to select the Plan records to update

        Returns
        -------
        int
            The total number of Plan records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Plan records
        total = await Plan.prisma().update_many(
            data={
                'id': 'bgehebiafc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Plan records present in the database

        Parameters
        ----------
        select
            Select the Plan fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Plan filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlanCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Plan.prisma().count()

        # results: prisma.types.PlanCountAggregateOutput
        results = await Plan.prisma().count(
            select={
                '_all': True,
                'companyId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlanCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
    ) -> types.PlanCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlanCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
    ) -> Union[int, types.PlanCountAggregateOutput]:
        """Count the number of Plan records present in the database

        Parameters
        ----------
        select
            Select the Plan fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Plan filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlanCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Plan.prisma().count()

        # results: prisma.types.PlanCountAggregateOutput
        results = await Plan.prisma().count(
            select={
                '_all': True,
                'seats': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlanCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlanWhereInput] = None
    ) -> int:
        """Delete multiple Plan records.

        Parameters
        ----------
        where
            Optional Plan filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Plan records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Plan records
        total = await Plan.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlanScalarFieldKeys'],
        *,
        where: Optional['types.PlanWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlanAvgAggregateInput'] = None,
        sum: Optional['types.PlanSumAggregateInput'] = None,
        min: Optional['types.PlanMinAggregateInput'] = None,
        max: Optional['types.PlanMaxAggregateInput'] = None,
        having: Optional['types.PlanScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlanCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlanScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PlanScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PlanGroupByOutput']:
        """Group Plan records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Plan fields to group records by
        where
            Plan filter to select records
        take
            Limit the maximum number of Plan records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlanGroupByOutput]
            A list of dictionaries representing the Plan record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Plan records by startedWithCredits values
        # and count how many records are in each group
        results = await Plan.prisma().group_by(
            ['startedWithCredits'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CloudSettingsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CloudSettings]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CloudSettings.prisma().query_raw(
            'SELECT * FROM CloudSettings WHERE id = $1',
            'bghffegacj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CloudSettings
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CloudSettings.prisma().query_first(
            'SELECT * FROM CloudSettings WHERE companyId = $1',
            'bhghchehcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CloudSettingsCreateInput,
        include: Optional[types.CloudSettingsInclude] = None
    ) -> _PrismaModelT:
        """Create a new CloudSettings record.

        Parameters
        ----------
        data
            CloudSettings record data
        include
            Specifies which relations should be loaded on the returned CloudSettings model

        Returns
        -------
        prisma.models.CloudSettings
            The created CloudSettings record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CloudSettings record from just the required fields
        cloudsettings = await CloudSettings.prisma().create(
            data={
                # data to create a CloudSettings record
                'companyId': 'dcgchcbbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CloudSettingsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CloudSettings records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CloudSettings record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CloudSettings.prisma().create_many(
            data=[
                {
                    # data to create a CloudSettings record
                    'companyId': 'bdedcabahc',
                },
                {
                    # data to create a CloudSettings record
                    'companyId': 'ghfhiafcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CloudSettingsWhereUniqueInput,
        include: Optional[types.CloudSettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CloudSettings record.

        Parameters
        ----------
        where
            CloudSettings filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CloudSettings model

        Returns
        -------
        prisma.models.CloudSettings
            The deleted CloudSettings record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cloudsettings = await CloudSettings.prisma().delete(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CloudSettingsWhereUniqueInput,
        include: Optional[types.CloudSettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CloudSettings record.

        Parameters
        ----------
        where
            CloudSettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CloudSettings model

        Returns
        -------
        prisma.models.CloudSettings
            The found CloudSettings record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cloudsettings = await CloudSettings.prisma().find_unique(
            where={
                'id': 'bjgjgibgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CloudSettingsWhereUniqueInput,
        include: Optional[types.CloudSettingsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CloudSettings record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CloudSettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CloudSettings model

        Returns
        -------
        prisma.models.CloudSettings
            The found CloudSettings record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cloudsettings = await CloudSettings.prisma().find_unique_or_raise(
            where={
                'id': 'bbbgbhfjge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CloudSettingsWhereInput] = None,
        cursor: Optional[types.CloudSettingsWhereUniqueInput] = None,
        include: Optional[types.CloudSettingsInclude] = None,
        order: Optional[Union[types.CloudSettingsOrderByInput, List[types.CloudSettingsOrderByInput]]] = None,
        distinct: Optional[List[types.CloudSettingsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CloudSettings records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CloudSettings records returned
        skip
            Ignore the first N results
        where
            CloudSettings filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CloudSettings model
        order
            Order the returned CloudSettings records by any field
        distinct
            Filter CloudSettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CloudSettings]
            The list of all CloudSettings records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CloudSettings records
        cloudsettings = await CloudSettings.prisma().find_many(take=10)

        # find the first 5 CloudSettings records ordered by the testingCompetitionFeature field
        cloudsettings = await CloudSettings.prisma().find_many(
            take=5,
            order={
                'testingCompetitionFeature': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CloudSettingsWhereInput] = None,
        cursor: Optional[types.CloudSettingsWhereUniqueInput] = None,
        include: Optional[types.CloudSettingsInclude] = None,
        order: Optional[Union[types.CloudSettingsOrderByInput, List[types.CloudSettingsOrderByInput]]] = None,
        distinct: Optional[List[types.CloudSettingsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CloudSettings record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CloudSettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CloudSettings model
        order
            Order the returned CloudSettings records by any field
        distinct
            Filter CloudSettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CloudSettings
            The first CloudSettings record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CloudSettings record ordered by the id field
        cloudsettings = await CloudSettings.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CloudSettingsWhereInput] = None,
        cursor: Optional[types.CloudSettingsWhereUniqueInput] = None,
        include: Optional[types.CloudSettingsInclude] = None,
        order: Optional[Union[types.CloudSettingsOrderByInput, List[types.CloudSettingsOrderByInput]]] = None,
        distinct: Optional[List[types.CloudSettingsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CloudSettings record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CloudSettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CloudSettings model
        order
            Order the returned CloudSettings records by any field
        distinct
            Filter CloudSettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CloudSettings
            The first CloudSettings record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CloudSettings record ordered by the companyId field
        cloudsettings = await CloudSettings.prisma().find_first_or_raise(
            skip=1,
            order={
                'companyId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CloudSettingsUpdateInput,
        where: types.CloudSettingsWhereUniqueInput,
        include: Optional[types.CloudSettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CloudSettings record.

        Parameters
        ----------
        data
            CloudSettings record data specifying what to update
        where
            CloudSettings filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CloudSettings model

        Returns
        -------
        prisma.models.CloudSettings
            The updated CloudSettings record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cloudsettings = await CloudSettings.prisma().update(
            where={
                'id': 'igbehcbab',
            },
            data={
                # data to update the CloudSettings record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CloudSettingsWhereUniqueInput,
        data: types.CloudSettingsUpsertInput,
        include: Optional[types.CloudSettingsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CloudSettings filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CloudSettings model

        Returns
        -------
        prisma.models.CloudSettings
            The created or updated CloudSettings record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cloudsettings = await CloudSettings.prisma().upsert(
            where={
                'id': 'bdadaadhag',
            },
            data={
                'create': {
                    'id': 'bdadaadhag',
                    'companyId': 'ghfhiafcb',
                },
                'update': {
                    'companyId': 'ghfhiafcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CloudSettingsUpdateManyMutationInput,
        where: types.CloudSettingsWhereInput,
    ) -> int:
        """Update multiple CloudSettings records

        Parameters
        ----------
        data
            CloudSettings data to update the selected CloudSettings records to
        where
            Filter to select the CloudSettings records to update

        Returns
        -------
        int
            The total number of CloudSettings records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CloudSettings records
        total = await CloudSettings.prisma().update_many(
            data={
                'testingCompetitionFeature': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CloudSettingsWhereInput] = None,
        cursor: Optional[types.CloudSettingsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CloudSettings records present in the database

        Parameters
        ----------
        select
            Select the CloudSettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CloudSettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CloudSettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CloudSettings.prisma().count()

        # results: prisma.types.CloudSettingsCountAggregateOutput
        results = await CloudSettings.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CloudSettingsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CloudSettingsWhereInput] = None,
        cursor: Optional[types.CloudSettingsWhereUniqueInput] = None,
    ) -> types.CloudSettingsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CloudSettingsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CloudSettingsWhereInput] = None,
        cursor: Optional[types.CloudSettingsWhereUniqueInput] = None,
    ) -> Union[int, types.CloudSettingsCountAggregateOutput]:
        """Count the number of CloudSettings records present in the database

        Parameters
        ----------
        select
            Select the CloudSettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CloudSettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CloudSettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CloudSettings.prisma().count()

        # results: prisma.types.CloudSettingsCountAggregateOutput
        results = await CloudSettings.prisma().count(
            select={
                '_all': True,
                'companyId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CloudSettingsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CloudSettingsWhereInput] = None
    ) -> int:
        """Delete multiple CloudSettings records.

        Parameters
        ----------
        where
            Optional CloudSettings filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CloudSettings records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CloudSettings records
        total = await CloudSettings.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CloudSettingsScalarFieldKeys'],
        *,
        where: Optional['types.CloudSettingsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CloudSettingsAvgAggregateInput'] = None,
        sum: Optional['types.CloudSettingsSumAggregateInput'] = None,
        min: Optional['types.CloudSettingsMinAggregateInput'] = None,
        max: Optional['types.CloudSettingsMaxAggregateInput'] = None,
        having: Optional['types.CloudSettingsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CloudSettingsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CloudSettingsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CloudSettingsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CloudSettingsGroupByOutput']:
        """Group CloudSettings records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CloudSettings fields to group records by
        where
            CloudSettings filter to select records
        take
            Limit the maximum number of CloudSettings records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CloudSettingsGroupByOutput]
            A list of dictionaries representing the CloudSettings record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CloudSettings records by testingCompetitionFeature values
        # and count how many records are in each group
        results = await CloudSettings.prisma().group_by(
            ['testingCompetitionFeature'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'caaaedabfc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'bigibebcib',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'bigaiehgcc',
                'password': 'beeifcbebf',
                'name': 'bgcigfahea',
                'companyId': 'bcejgaggif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'idfjadbcc',
                    'password': 'hgdhbjhhj',
                    'name': 'ecjjjfbae',
                    'companyId': 'bhhfibbigf',
                },
                {
                    # data to create a User record
                    'email': 'ijdbeffgg',
                    'password': 'jjfeafhfj',
                    'name': 'cbachdgfce',
                    'companyId': 'chbfcacbd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'efggddide',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'caficfigfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'bfidgijfjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the password field
        users = await User.prisma().find_many(
            take=5,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the name field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the companyId field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'companyId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'ihieecagf',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bghfciaafe',
            },
            data={
                'create': {
                    'id': 'bghfciaafe',
                    'email': 'ijdbeffgg',
                    'password': 'jjfeafhfj',
                    'name': 'cbachdgfce',
                    'companyId': 'chbfcacbd',
                },
                'update': {
                    'email': 'ijdbeffgg',
                    'password': 'jjfeafhfj',
                    'name': 'cbachdgfce',
                    'companyId': 'chbfcacbd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'image': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'userRole': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by tag values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['tag'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DeviceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Device]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Device.prisma().query_raw(
            'SELECT * FROM Device WHERE id = $1',
            'bgchfhgceh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Device
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Device.prisma().query_first(
            'SELECT * FROM Device WHERE imei = $1',
            'cafeiaccbc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DeviceCreateInput,
        include: Optional[types.DeviceInclude] = None
    ) -> _PrismaModelT:
        """Create a new Device record.

        Parameters
        ----------
        data
            Device record data
        include
            Specifies which relations should be loaded on the returned Device model

        Returns
        -------
        prisma.models.Device
            The created Device record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Device record from just the required fields
        device = await Device.prisma().create(
            data={
                # data to create a Device record
                'imei': 'gaddfhfh',
                'companyId': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DeviceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Device records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Device record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Device.prisma().create_many(
            data=[
                {
                    # data to create a Device record
                    'imei': 'bgcffadich',
                    'companyId': 'fcbichhci',
                },
                {
                    # data to create a Device record
                    'imei': 'bcggadccgf',
                    'companyId': 'jdcfdcgc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DeviceWhereUniqueInput,
        include: Optional[types.DeviceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Device record.

        Parameters
        ----------
        where
            Device filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Device model

        Returns
        -------
        prisma.models.Device
            The deleted Device record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        device = await Device.prisma().delete(
            where={
                'id': 'cafdaehjid',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DeviceWhereUniqueInput,
        include: Optional[types.DeviceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Device record.

        Parameters
        ----------
        where
            Device filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Device model

        Returns
        -------
        prisma.models.Device
            The found Device record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        device = await Device.prisma().find_unique(
            where={
                'id': 'gifdddbia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DeviceWhereUniqueInput,
        include: Optional[types.DeviceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Device record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Device filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Device model

        Returns
        -------
        prisma.models.Device
            The found Device record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        device = await Device.prisma().find_unique_or_raise(
            where={
                'id': 'bchehecef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DeviceWhereInput] = None,
        cursor: Optional[types.DeviceWhereUniqueInput] = None,
        include: Optional[types.DeviceInclude] = None,
        order: Optional[Union[types.DeviceOrderByInput, List[types.DeviceOrderByInput]]] = None,
        distinct: Optional[List[types.DeviceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Device records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Device records returned
        skip
            Ignore the first N results
        where
            Device filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Device model
        order
            Order the returned Device records by any field
        distinct
            Filter Device records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Device]
            The list of all Device records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Device records
        devices = await Device.prisma().find_many(take=10)

        # find the first 5 Device records ordered by the companyId field
        devices = await Device.prisma().find_many(
            take=5,
            order={
                'companyId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DeviceWhereInput] = None,
        cursor: Optional[types.DeviceWhereUniqueInput] = None,
        include: Optional[types.DeviceInclude] = None,
        order: Optional[Union[types.DeviceOrderByInput, List[types.DeviceOrderByInput]]] = None,
        distinct: Optional[List[types.DeviceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Device record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Device filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Device model
        order
            Order the returned Device records by any field
        distinct
            Filter Device records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Device
            The first Device record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Device record ordered by the model field
        device = await Device.prisma().find_first(
            skip=1,
            order={
                'model': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DeviceWhereInput] = None,
        cursor: Optional[types.DeviceWhereUniqueInput] = None,
        include: Optional[types.DeviceInclude] = None,
        order: Optional[Union[types.DeviceOrderByInput, List[types.DeviceOrderByInput]]] = None,
        distinct: Optional[List[types.DeviceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Device record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Device filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Device model
        order
            Order the returned Device records by any field
        distinct
            Filter Device records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Device
            The first Device record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Device record ordered by the createdAt field
        device = await Device.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DeviceUpdateInput,
        where: types.DeviceWhereUniqueInput,
        include: Optional[types.DeviceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Device record.

        Parameters
        ----------
        data
            Device record data specifying what to update
        where
            Device filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Device model

        Returns
        -------
        prisma.models.Device
            The updated Device record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        device = await Device.prisma().update(
            where={
                'id': 'jeijcbhfe',
            },
            data={
                # data to update the Device record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DeviceWhereUniqueInput,
        data: types.DeviceUpsertInput,
        include: Optional[types.DeviceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Device filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Device model

        Returns
        -------
        prisma.models.Device
            The created or updated Device record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        device = await Device.prisma().upsert(
            where={
                'id': 'bjgejjabff',
            },
            data={
                'create': {
                    'id': 'bjgejjabff',
                    'imei': 'bcggadccgf',
                    'companyId': 'jdcfdcgc',
                },
                'update': {
                    'imei': 'bcggadccgf',
                    'companyId': 'jdcfdcgc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DeviceUpdateManyMutationInput,
        where: types.DeviceWhereInput,
    ) -> int:
        """Update multiple Device records

        Parameters
        ----------
        data
            Device data to update the selected Device records to
        where
            Filter to select the Device records to update

        Returns
        -------
        int
            The total number of Device records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Device records
        total = await Device.prisma().update_many(
            data={
                'brand': 'bcciijbibg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DeviceWhereInput] = None,
        cursor: Optional[types.DeviceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Device records present in the database

        Parameters
        ----------
        select
            Select the Device fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Device filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DeviceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Device.prisma().count()

        # results: prisma.types.DeviceCountAggregateOutput
        results = await Device.prisma().count(
            select={
                '_all': True,
                'code': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DeviceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DeviceWhereInput] = None,
        cursor: Optional[types.DeviceWhereUniqueInput] = None,
    ) -> types.DeviceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DeviceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DeviceWhereInput] = None,
        cursor: Optional[types.DeviceWhereUniqueInput] = None,
    ) -> Union[int, types.DeviceCountAggregateOutput]:
        """Count the number of Device records present in the database

        Parameters
        ----------
        select
            Select the Device fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Device filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DeviceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Device.prisma().count()

        # results: prisma.types.DeviceCountAggregateOutput
        results = await Device.prisma().count(
            select={
                '_all': True,
                'simSlots': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DeviceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DeviceWhereInput] = None
    ) -> int:
        """Delete multiple Device records.

        Parameters
        ----------
        where
            Optional Device filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Device records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Device records
        total = await Device.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DeviceScalarFieldKeys'],
        *,
        where: Optional['types.DeviceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DeviceAvgAggregateInput'] = None,
        sum: Optional['types.DeviceSumAggregateInput'] = None,
        min: Optional['types.DeviceMinAggregateInput'] = None,
        max: Optional['types.DeviceMaxAggregateInput'] = None,
        having: Optional['types.DeviceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DeviceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DeviceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DeviceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DeviceGroupByOutput']:
        """Group Device records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Device fields to group records by
        where
            Device filter to select records
        take
            Limit the maximum number of Device records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DeviceGroupByOutput]
            A list of dictionaries representing the Device record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Device records by batteryTech values
        # and count how many records are in each group
        results = await Device.prisma().group_by(
            ['batteryTech'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TestResultActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TestResult]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TestResult.prisma().query_raw(
            'SELECT * FROM TestResult WHERE id = $1',
            'cffcachfd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TestResult
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TestResult.prisma().query_first(
            'SELECT * FROM TestResult WHERE result = $1',
            'bccdfhdigc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TestResultCreateInput,
        include: Optional[types.TestResultInclude] = None
    ) -> _PrismaModelT:
        """Create a new TestResult record.

        Parameters
        ----------
        data
            TestResult record data
        include
            Specifies which relations should be loaded on the returned TestResult model

        Returns
        -------
        prisma.models.TestResult
            The created TestResult record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TestResult record from just the required fields
        testresult = await TestResult.prisma().create(
            data={
                # data to create a TestResult record
                'result': 'febcgjbfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TestResultCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TestResult records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TestResult record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TestResult.prisma().create_many(
            data=[
                {
                    # data to create a TestResult record
                    'result': 'bageiegghg',
                },
                {
                    # data to create a TestResult record
                    'result': 'faidicegb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TestResultWhereUniqueInput,
        include: Optional[types.TestResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TestResult record.

        Parameters
        ----------
        where
            TestResult filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TestResult model

        Returns
        -------
        prisma.models.TestResult
            The deleted TestResult record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        testresult = await TestResult.prisma().delete(
            where={
                'id': 'bacecgfhbe',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TestResultWhereUniqueInput,
        include: Optional[types.TestResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TestResult record.

        Parameters
        ----------
        where
            TestResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TestResult model

        Returns
        -------
        prisma.models.TestResult
            The found TestResult record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        testresult = await TestResult.prisma().find_unique(
            where={
                'id': 'ihcahiead',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TestResultWhereUniqueInput,
        include: Optional[types.TestResultInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TestResult record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TestResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TestResult model

        Returns
        -------
        prisma.models.TestResult
            The found TestResult record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        testresult = await TestResult.prisma().find_unique_or_raise(
            where={
                'id': 'biheheiajg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TestResultWhereInput] = None,
        cursor: Optional[types.TestResultWhereUniqueInput] = None,
        include: Optional[types.TestResultInclude] = None,
        order: Optional[Union[types.TestResultOrderByInput, List[types.TestResultOrderByInput]]] = None,
        distinct: Optional[List[types.TestResultScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TestResult records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TestResult records returned
        skip
            Ignore the first N results
        where
            TestResult filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TestResult model
        order
            Order the returned TestResult records by any field
        distinct
            Filter TestResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TestResult]
            The list of all TestResult records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TestResult records
        testresults = await TestResult.prisma().find_many(take=10)

        # find the first 5 TestResult records ordered by the testerId field
        testresults = await TestResult.prisma().find_many(
            take=5,
            order={
                'testerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TestResultWhereInput] = None,
        cursor: Optional[types.TestResultWhereUniqueInput] = None,
        include: Optional[types.TestResultInclude] = None,
        order: Optional[Union[types.TestResultOrderByInput, List[types.TestResultOrderByInput]]] = None,
        distinct: Optional[List[types.TestResultScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TestResult record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TestResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TestResult model
        order
            Order the returned TestResult records by any field
        distinct
            Filter TestResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TestResult
            The first TestResult record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TestResult record ordered by the deviceId field
        testresult = await TestResult.prisma().find_first(
            skip=1,
            order={
                'deviceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TestResultWhereInput] = None,
        cursor: Optional[types.TestResultWhereUniqueInput] = None,
        include: Optional[types.TestResultInclude] = None,
        order: Optional[Union[types.TestResultOrderByInput, List[types.TestResultOrderByInput]]] = None,
        distinct: Optional[List[types.TestResultScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TestResult record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TestResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TestResult model
        order
            Order the returned TestResult records by any field
        distinct
            Filter TestResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TestResult
            The first TestResult record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TestResult record ordered by the status field
        testresult = await TestResult.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TestResultUpdateInput,
        where: types.TestResultWhereUniqueInput,
        include: Optional[types.TestResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TestResult record.

        Parameters
        ----------
        data
            TestResult record data specifying what to update
        where
            TestResult filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TestResult model

        Returns
        -------
        prisma.models.TestResult
            The updated TestResult record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        testresult = await TestResult.prisma().update(
            where={
                'id': 'jbgijghgb',
            },
            data={
                # data to update the TestResult record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TestResultWhereUniqueInput,
        data: types.TestResultUpsertInput,
        include: Optional[types.TestResultInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TestResult filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TestResult model

        Returns
        -------
        prisma.models.TestResult
            The created or updated TestResult record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        testresult = await TestResult.prisma().upsert(
            where={
                'id': 'hgjcghfbi',
            },
            data={
                'create': {
                    'id': 'hgjcghfbi',
                    'result': 'faidicegb',
                },
                'update': {
                    'result': 'faidicegb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TestResultUpdateManyMutationInput,
        where: types.TestResultWhereInput,
    ) -> int:
        """Update multiple TestResult records

        Parameters
        ----------
        data
            TestResult data to update the selected TestResult records to
        where
            Filter to select the TestResult records to update

        Returns
        -------
        int
            The total number of TestResult records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TestResult records
        total = await TestResult.prisma().update_many(
            data={
                'time': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TestResultWhereInput] = None,
        cursor: Optional[types.TestResultWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TestResult records present in the database

        Parameters
        ----------
        select
            Select the TestResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TestResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TestResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TestResult.prisma().count()

        # results: prisma.types.TestResultCountAggregateOutput
        results = await TestResult.prisma().count(
            select={
                '_all': True,
                'batteryLife': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TestResultCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TestResultWhereInput] = None,
        cursor: Optional[types.TestResultWhereUniqueInput] = None,
    ) -> types.TestResultCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TestResultCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TestResultWhereInput] = None,
        cursor: Optional[types.TestResultWhereUniqueInput] = None,
    ) -> Union[int, types.TestResultCountAggregateOutput]:
        """Count the number of TestResult records present in the database

        Parameters
        ----------
        select
            Select the TestResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TestResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TestResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TestResult.prisma().count()

        # results: prisma.types.TestResultCountAggregateOutput
        results = await TestResult.prisma().count(
            select={
                '_all': True,
                'cycleCount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TestResultCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TestResultWhereInput] = None
    ) -> int:
        """Delete multiple TestResult records.

        Parameters
        ----------
        where
            Optional TestResult filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TestResult records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TestResult records
        total = await TestResult.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TestResultScalarFieldKeys'],
        *,
        where: Optional['types.TestResultWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TestResultAvgAggregateInput'] = None,
        sum: Optional['types.TestResultSumAggregateInput'] = None,
        min: Optional['types.TestResultMinAggregateInput'] = None,
        max: Optional['types.TestResultMaxAggregateInput'] = None,
        having: Optional['types.TestResultScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TestResultCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TestResultScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TestResultScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TestResultGroupByOutput']:
        """Group TestResult records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TestResult fields to group records by
        where
            TestResult filter to select records
        take
            Limit the maximum number of TestResult records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TestResultGroupByOutput]
            A list of dictionaries representing the TestResult record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TestResult records by frp values
        # and count how many records are in each group
        results = await TestResult.prisma().group_by(
            ['frp'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CertificateActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Certificate]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Certificate.prisma().query_raw(
            'SELECT * FROM Certificate WHERE id = $1',
            'icadbcehj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Certificate
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Certificate.prisma().query_first(
            'SELECT * FROM Certificate WHERE testResultId = $1',
            'jchciaee',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CertificateCreateInput,
        include: Optional[types.CertificateInclude] = None
    ) -> _PrismaModelT:
        """Create a new Certificate record.

        Parameters
        ----------
        data
            Certificate record data
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The created Certificate record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Certificate record from just the required fields
        certificate = await Certificate.prisma().create(
            data={
                # data to create a Certificate record
                'testResultId': 'deeificjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CertificateCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Certificate records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Certificate record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Certificate.prisma().create_many(
            data=[
                {
                    # data to create a Certificate record
                    'testResultId': 'bbcbhebbda',
                },
                {
                    # data to create a Certificate record
                    'testResultId': 'bejfijgcfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CertificateWhereUniqueInput,
        include: Optional[types.CertificateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Certificate record.

        Parameters
        ----------
        where
            Certificate filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The deleted Certificate record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        certificate = await Certificate.prisma().delete(
            where={
                'id': 'caifcbgii',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CertificateWhereUniqueInput,
        include: Optional[types.CertificateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Certificate record.

        Parameters
        ----------
        where
            Certificate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The found Certificate record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        certificate = await Certificate.prisma().find_unique(
            where={
                'id': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CertificateWhereUniqueInput,
        include: Optional[types.CertificateInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Certificate record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Certificate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The found Certificate record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        certificate = await Certificate.prisma().find_unique_or_raise(
            where={
                'id': 'bggajdcbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
        include: Optional[types.CertificateInclude] = None,
        order: Optional[Union[types.CertificateOrderByInput, List[types.CertificateOrderByInput]]] = None,
        distinct: Optional[List[types.CertificateScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Certificate records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Certificate records returned
        skip
            Ignore the first N results
        where
            Certificate filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Certificate model
        order
            Order the returned Certificate records by any field
        distinct
            Filter Certificate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Certificate]
            The list of all Certificate records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Certificate records
        certificates = await Certificate.prisma().find_many(take=10)

        # find the first 5 Certificate records ordered by the expiration field
        certificates = await Certificate.prisma().find_many(
            take=5,
            order={
                'expiration': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
        include: Optional[types.CertificateInclude] = None,
        order: Optional[Union[types.CertificateOrderByInput, List[types.CertificateOrderByInput]]] = None,
        distinct: Optional[List[types.CertificateScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Certificate record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Certificate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Certificate model
        order
            Order the returned Certificate records by any field
        distinct
            Filter Certificate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Certificate
            The first Certificate record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Certificate record ordered by the createdAt field
        certificate = await Certificate.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
        include: Optional[types.CertificateInclude] = None,
        order: Optional[Union[types.CertificateOrderByInput, List[types.CertificateOrderByInput]]] = None,
        distinct: Optional[List[types.CertificateScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Certificate record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Certificate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Certificate model
        order
            Order the returned Certificate records by any field
        distinct
            Filter Certificate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Certificate
            The first Certificate record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Certificate record ordered by the id field
        certificate = await Certificate.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CertificateUpdateInput,
        where: types.CertificateWhereUniqueInput,
        include: Optional[types.CertificateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Certificate record.

        Parameters
        ----------
        data
            Certificate record data specifying what to update
        where
            Certificate filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The updated Certificate record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        certificate = await Certificate.prisma().update(
            where={
                'id': 'fcfhgbjed',
            },
            data={
                # data to update the Certificate record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CertificateWhereUniqueInput,
        data: types.CertificateUpsertInput,
        include: Optional[types.CertificateInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Certificate filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The created or updated Certificate record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        certificate = await Certificate.prisma().upsert(
            where={
                'id': 'hdgcajhjg',
            },
            data={
                'create': {
                    'id': 'hdgcajhjg',
                    'testResultId': 'bejfijgcfb',
                },
                'update': {
                    'testResultId': 'bejfijgcfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CertificateUpdateManyMutationInput,
        where: types.CertificateWhereInput,
    ) -> int:
        """Update multiple Certificate records

        Parameters
        ----------
        data
            Certificate data to update the selected Certificate records to
        where
            Filter to select the Certificate records to update

        Returns
        -------
        int
            The total number of Certificate records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Certificate records
        total = await Certificate.prisma().update_many(
            data={
                'testResultId': 'ejdjahicb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Certificate records present in the database

        Parameters
        ----------
        select
            Select the Certificate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Certificate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CertificateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Certificate.prisma().count()

        # results: prisma.types.CertificateCountAggregateOutput
        results = await Certificate.prisma().count(
            select={
                '_all': True,
                'expiration': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CertificateCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
    ) -> types.CertificateCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CertificateCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
    ) -> Union[int, types.CertificateCountAggregateOutput]:
        """Count the number of Certificate records present in the database

        Parameters
        ----------
        select
            Select the Certificate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Certificate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CertificateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Certificate.prisma().count()

        # results: prisma.types.CertificateCountAggregateOutput
        results = await Certificate.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CertificateCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CertificateWhereInput] = None
    ) -> int:
        """Delete multiple Certificate records.

        Parameters
        ----------
        where
            Optional Certificate filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Certificate records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Certificate records
        total = await Certificate.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CertificateScalarFieldKeys'],
        *,
        where: Optional['types.CertificateWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CertificateAvgAggregateInput'] = None,
        sum: Optional['types.CertificateSumAggregateInput'] = None,
        min: Optional['types.CertificateMinAggregateInput'] = None,
        max: Optional['types.CertificateMaxAggregateInput'] = None,
        having: Optional['types.CertificateScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CertificateCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CertificateScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CertificateScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CertificateGroupByOutput']:
        """Group Certificate records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Certificate fields to group records by
        where
            Certificate filter to select records
        take
            Limit the maximum number of Certificate records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CertificateGroupByOutput]
            A list of dictionaries representing the Certificate record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Certificate records by id values
        # and count how many records are in each group
        results = await Certificate.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Session.prisma().query_raw(
            'SELECT * FROM Session WHERE id = $1',
            'gdjgigfgc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Session.prisma().query_first(
            'SELECT * FROM Session WHERE userId = $1',
            'gfeaahdeh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SessionCreateInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Session record.

        Parameters
        ----------
        data
            Session record data
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created Session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Session record from just the required fields
        session = await Session.prisma().create(
            data={
                # data to create a Session record
                'userId': 'bjafcgbffc',
                'token': 'hihegjif',
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Session.prisma().create_many(
            data=[
                {
                    # data to create a Session record
                    'userId': 'bdjidcidac',
                    'token': 'ifgaaagff',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Session record
                    'userId': 'befcddgjce',
                    'token': 'bfhdbjjgfd',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Session record.

        Parameters
        ----------
        where
            Session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The deleted Session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().delete(
            where={
                'id': 'cabdjadaji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Session record.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique(
            where={
                'id': 'faajgfadf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique_or_raise(
            where={
                'id': 'biaagcedjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N results
        where
            Session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Session]
            The list of all Session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Session records
        sessions = await Session.prisma().find_many(take=10)

        # find the first 5 Session records ordered by the token field
        sessions = await Session.prisma().find_many(
            take=5,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the expiresAt field
        session = await Session.prisma().find_first(
            skip=1,
            order={
                'expiresAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the createdAt field
        session = await Session.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SessionUpdateInput,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Session record.

        Parameters
        ----------
        data
            Session record data specifying what to update
        where
            Session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The updated Session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        session = await Session.prisma().update(
            where={
                'id': 'cahhaghecf',
            },
            data={
                # data to update the Session record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SessionWhereUniqueInput,
        data: types.SessionUpsertInput,
        include: Optional[types.SessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created or updated Session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().upsert(
            where={
                'id': 'bghcbbcidi',
            },
            data={
                'create': {
                    'id': 'bghcbbcidi',
                    'userId': 'befcddgjce',
                    'token': 'bfhdbjjgfd',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 'befcddgjce',
                    'token': 'bfhdbjjgfd',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SessionUpdateManyMutationInput,
        where: types.SessionWhereInput,
    ) -> int:
        """Update multiple Session records

        Parameters
        ----------
        data
            Session data to update the selected Session records to
        where
            Filter to select the Session records to update

        Returns
        -------
        int
            The total number of Session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Session records
        total = await Session.prisma().update_many(
            data={
                'id': 'jcgghhgdj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> types.SessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> Union[int, types.SessionCountAggregateOutput]:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SessionWhereInput] = None
    ) -> int:
        """Delete multiple Session records.

        Parameters
        ----------
        where
            Optional Session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Session records
        total = await Session.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SessionScalarFieldKeys'],
        *,
        where: Optional['types.SessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SessionAvgAggregateInput'] = None,
        sum: Optional['types.SessionSumAggregateInput'] = None,
        min: Optional['types.SessionMinAggregateInput'] = None,
        max: Optional['types.SessionMaxAggregateInput'] = None,
        having: Optional['types.SessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SessionGroupByOutput']:
        """Group Session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Session fields to group records by
        where
            Session filter to select records
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SessionGroupByOutput]
            A list of dictionaries representing the Session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Session records by expiresAt values
        # and count how many records are in each group
        results = await Session.prisma().group_by(
            ['expiresAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CloudSessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CloudSession]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CloudSession.prisma().query_raw(
            'SELECT * FROM CloudSession WHERE id = $1',
            'beehgcebbg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CloudSession
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CloudSession.prisma().query_first(
            'SELECT * FROM CloudSession WHERE userId = $1',
            'bhdiaidiaf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CloudSessionCreateInput,
        include: Optional[types.CloudSessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new CloudSession record.

        Parameters
        ----------
        data
            CloudSession record data
        include
            Specifies which relations should be loaded on the returned CloudSession model

        Returns
        -------
        prisma.models.CloudSession
            The created CloudSession record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CloudSession record from just the required fields
        cloudsession = await CloudSession.prisma().create(
            data={
                # data to create a CloudSession record
                'userId': 'deajegcfi',
                'token': 'gabahhhjf',
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CloudSessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CloudSession records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CloudSession record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CloudSession.prisma().create_many(
            data=[
                {
                    # data to create a CloudSession record
                    'userId': 'cjagadcjg',
                    'token': 'bifficggej',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a CloudSession record
                    'userId': 'bgbbaajbic',
                    'token': 'eegghdhjb',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CloudSessionWhereUniqueInput,
        include: Optional[types.CloudSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CloudSession record.

        Parameters
        ----------
        where
            CloudSession filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CloudSession model

        Returns
        -------
        prisma.models.CloudSession
            The deleted CloudSession record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cloudsession = await CloudSession.prisma().delete(
            where={
                'id': 'daafgidjg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CloudSessionWhereUniqueInput,
        include: Optional[types.CloudSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CloudSession record.

        Parameters
        ----------
        where
            CloudSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CloudSession model

        Returns
        -------
        prisma.models.CloudSession
            The found CloudSession record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cloudsession = await CloudSession.prisma().find_unique(
            where={
                'id': 'gdcgcgagj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CloudSessionWhereUniqueInput,
        include: Optional[types.CloudSessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CloudSession record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CloudSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CloudSession model

        Returns
        -------
        prisma.models.CloudSession
            The found CloudSession record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cloudsession = await CloudSession.prisma().find_unique_or_raise(
            where={
                'id': 'bhceabbgja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CloudSessionWhereInput] = None,
        cursor: Optional[types.CloudSessionWhereUniqueInput] = None,
        include: Optional[types.CloudSessionInclude] = None,
        order: Optional[Union[types.CloudSessionOrderByInput, List[types.CloudSessionOrderByInput]]] = None,
        distinct: Optional[List[types.CloudSessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CloudSession records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CloudSession records returned
        skip
            Ignore the first N results
        where
            CloudSession filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CloudSession model
        order
            Order the returned CloudSession records by any field
        distinct
            Filter CloudSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CloudSession]
            The list of all CloudSession records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CloudSession records
        cloudsessions = await CloudSession.prisma().find_many(take=10)

        # find the first 5 CloudSession records ordered by the token field
        cloudsessions = await CloudSession.prisma().find_many(
            take=5,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CloudSessionWhereInput] = None,
        cursor: Optional[types.CloudSessionWhereUniqueInput] = None,
        include: Optional[types.CloudSessionInclude] = None,
        order: Optional[Union[types.CloudSessionOrderByInput, List[types.CloudSessionOrderByInput]]] = None,
        distinct: Optional[List[types.CloudSessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CloudSession record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CloudSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CloudSession model
        order
            Order the returned CloudSession records by any field
        distinct
            Filter CloudSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CloudSession
            The first CloudSession record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CloudSession record ordered by the expiresAt field
        cloudsession = await CloudSession.prisma().find_first(
            skip=1,
            order={
                'expiresAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CloudSessionWhereInput] = None,
        cursor: Optional[types.CloudSessionWhereUniqueInput] = None,
        include: Optional[types.CloudSessionInclude] = None,
        order: Optional[Union[types.CloudSessionOrderByInput, List[types.CloudSessionOrderByInput]]] = None,
        distinct: Optional[List[types.CloudSessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CloudSession record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CloudSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CloudSession model
        order
            Order the returned CloudSession records by any field
        distinct
            Filter CloudSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CloudSession
            The first CloudSession record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CloudSession record ordered by the createdAt field
        cloudsession = await CloudSession.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CloudSessionUpdateInput,
        where: types.CloudSessionWhereUniqueInput,
        include: Optional[types.CloudSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CloudSession record.

        Parameters
        ----------
        data
            CloudSession record data specifying what to update
        where
            CloudSession filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CloudSession model

        Returns
        -------
        prisma.models.CloudSession
            The updated CloudSession record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cloudsession = await CloudSession.prisma().update(
            where={
                'id': 'ehabfhegh',
            },
            data={
                # data to update the CloudSession record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CloudSessionWhereUniqueInput,
        data: types.CloudSessionUpsertInput,
        include: Optional[types.CloudSessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CloudSession filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CloudSession model

        Returns
        -------
        prisma.models.CloudSession
            The created or updated CloudSession record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cloudsession = await CloudSession.prisma().upsert(
            where={
                'id': 'bcajcajjbc',
            },
            data={
                'create': {
                    'id': 'bcajcajjbc',
                    'userId': 'bgbbaajbic',
                    'token': 'eegghdhjb',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 'bgbbaajbic',
                    'token': 'eegghdhjb',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CloudSessionUpdateManyMutationInput,
        where: types.CloudSessionWhereInput,
    ) -> int:
        """Update multiple CloudSession records

        Parameters
        ----------
        data
            CloudSession data to update the selected CloudSession records to
        where
            Filter to select the CloudSession records to update

        Returns
        -------
        int
            The total number of CloudSession records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CloudSession records
        total = await CloudSession.prisma().update_many(
            data={
                'id': 'bfdgheeegf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CloudSessionWhereInput] = None,
        cursor: Optional[types.CloudSessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CloudSession records present in the database

        Parameters
        ----------
        select
            Select the CloudSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CloudSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CloudSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CloudSession.prisma().count()

        # results: prisma.types.CloudSessionCountAggregateOutput
        results = await CloudSession.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CloudSessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CloudSessionWhereInput] = None,
        cursor: Optional[types.CloudSessionWhereUniqueInput] = None,
    ) -> types.CloudSessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CloudSessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CloudSessionWhereInput] = None,
        cursor: Optional[types.CloudSessionWhereUniqueInput] = None,
    ) -> Union[int, types.CloudSessionCountAggregateOutput]:
        """Count the number of CloudSession records present in the database

        Parameters
        ----------
        select
            Select the CloudSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CloudSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CloudSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CloudSession.prisma().count()

        # results: prisma.types.CloudSessionCountAggregateOutput
        results = await CloudSession.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CloudSessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CloudSessionWhereInput] = None
    ) -> int:
        """Delete multiple CloudSession records.

        Parameters
        ----------
        where
            Optional CloudSession filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CloudSession records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CloudSession records
        total = await CloudSession.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CloudSessionScalarFieldKeys'],
        *,
        where: Optional['types.CloudSessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CloudSessionAvgAggregateInput'] = None,
        sum: Optional['types.CloudSessionSumAggregateInput'] = None,
        min: Optional['types.CloudSessionMinAggregateInput'] = None,
        max: Optional['types.CloudSessionMaxAggregateInput'] = None,
        having: Optional['types.CloudSessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CloudSessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CloudSessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CloudSessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CloudSessionGroupByOutput']:
        """Group CloudSession records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CloudSession fields to group records by
        where
            CloudSession filter to select records
        take
            Limit the maximum number of CloudSession records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CloudSessionGroupByOutput]
            A list of dictionaries representing the CloudSession record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CloudSession records by expiresAt values
        # and count how many records are in each group
        results = await CloudSession.prisma().group_by(
            ['expiresAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TransactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Transaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Transaction.prisma().query_raw(
            'SELECT * FROM Transaction WHERE id = $1',
            'ececbijji',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Transaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Transaction.prisma().query_first(
            'SELECT * FROM Transaction WHERE companyId = $1',
            'cbcfgdcdhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TransactionCreateInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Transaction record.

        Parameters
        ----------
        data
            Transaction record data
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created Transaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Transaction record from just the required fields
        transaction = await Transaction.prisma().create(
            data={
                # data to create a Transaction record
                'companyId': 'fdgjfbhia',
                'balanceAfter': 924723277,
                'userId': 'bgcbjdhjcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TransactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Transaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Transaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Transaction.prisma().create_many(
            data=[
                {
                    # data to create a Transaction record
                    'companyId': 'bieiidcabj',
                    'balanceAfter': 1921528400,
                    'userId': 'cbaaechiej',
                },
                {
                    # data to create a Transaction record
                    'companyId': 'iejbeaaeg',
                    'balanceAfter': 928152175,
                    'userId': 'chdadcaga',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Transaction record.

        Parameters
        ----------
        where
            Transaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The deleted Transaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().delete(
            where={
                'id': 'jicieifbh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Transaction record.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique(
            where={
                'id': 'fbahdheji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Transaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique_or_raise(
            where={
                'id': 'cbbheiicgh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Transaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N results
        where
            Transaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Transaction]
            The list of all Transaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Transaction records
        transactions = await Transaction.prisma().find_many(take=10)

        # find the first 5 Transaction records ordered by the imei field
        transactions = await Transaction.prisma().find_many(
            take=5,
            order={
                'imei': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Transaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the createdAt field
        transaction = await Transaction.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Transaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the amount field
        transaction = await Transaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TransactionUpdateInput,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Transaction record.

        Parameters
        ----------
        data
            Transaction record data specifying what to update
        where
            Transaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The updated Transaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transaction = await Transaction.prisma().update(
            where={
                'id': 'beabjeejdg',
            },
            data={
                # data to update the Transaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TransactionWhereUniqueInput,
        data: types.TransactionUpsertInput,
        include: Optional[types.TransactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Transaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created or updated Transaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().upsert(
            where={
                'id': 'bcjhgahffd',
            },
            data={
                'create': {
                    'id': 'bcjhgahffd',
                    'companyId': 'iejbeaaeg',
                    'balanceAfter': 928152175,
                    'userId': 'chdadcaga',
                },
                'update': {
                    'companyId': 'iejbeaaeg',
                    'balanceAfter': 928152175,
                    'userId': 'chdadcaga',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TransactionUpdateManyMutationInput,
        where: types.TransactionWhereInput,
    ) -> int:
        """Update multiple Transaction records

        Parameters
        ----------
        data
            Transaction data to update the selected Transaction records to
        where
            Filter to select the Transaction records to update

        Returns
        -------
        int
            The total number of Transaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Transaction records
        total = await Transaction.prisma().update_many(
            data={
                'balanceAfter': 519488550
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TransactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> types.TransactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TransactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> Union[int, types.TransactionCountAggregateOutput]:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'processedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TransactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TransactionWhereInput] = None
    ) -> int:
        """Delete multiple Transaction records.

        Parameters
        ----------
        where
            Optional Transaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Transaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Transaction records
        total = await Transaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TransactionScalarFieldKeys'],
        *,
        where: Optional['types.TransactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TransactionAvgAggregateInput'] = None,
        sum: Optional['types.TransactionSumAggregateInput'] = None,
        min: Optional['types.TransactionMinAggregateInput'] = None,
        max: Optional['types.TransactionMaxAggregateInput'] = None,
        having: Optional['types.TransactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TransactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TransactionGroupByOutput']:
        """Group Transaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Transaction fields to group records by
        where
            Transaction filter to select records
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TransactionGroupByOutput]
            A list of dictionaries representing the Transaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Transaction records by reason values
        # and count how many records are in each group
        results = await Transaction.prisma().group_by(
            ['reason'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MobileNetworksActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.MobileNetworks]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await MobileNetworks.prisma().query_raw(
            'SELECT * FROM MobileNetworks WHERE id = $1',
            'jhgidcgbf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.MobileNetworks
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await MobileNetworks.prisma().query_first(
            'SELECT * FROM MobileNetworks WHERE mcc = $1',
            'bgjgecfejc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MobileNetworksCreateInput,
        include: Optional[types.MobileNetworksInclude] = None
    ) -> _PrismaModelT:
        """Create a new MobileNetworks record.

        Parameters
        ----------
        data
            MobileNetworks record data
        include
            Specifies which relations should be loaded on the returned MobileNetworks model

        Returns
        -------
        prisma.models.MobileNetworks
            The created MobileNetworks record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a MobileNetworks record from just the required fields
        mobilenetworks = await MobileNetworks.prisma().create(
            data={
                # data to create a MobileNetworks record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MobileNetworksCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple MobileNetworks records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of MobileNetworks record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await MobileNetworks.prisma().create_many(
            data=[
                {
                    # data to create a MobileNetworks record
                },
                {
                    # data to create a MobileNetworks record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MobileNetworksWhereUniqueInput,
        include: Optional[types.MobileNetworksInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single MobileNetworks record.

        Parameters
        ----------
        where
            MobileNetworks filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned MobileNetworks model

        Returns
        -------
        prisma.models.MobileNetworks
            The deleted MobileNetworks record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mobilenetworks = await MobileNetworks.prisma().delete(
            where={
                'id': 'bgjcgchib',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MobileNetworksWhereUniqueInput,
        include: Optional[types.MobileNetworksInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique MobileNetworks record.

        Parameters
        ----------
        where
            MobileNetworks filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MobileNetworks model

        Returns
        -------
        prisma.models.MobileNetworks
            The found MobileNetworks record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mobilenetworks = await MobileNetworks.prisma().find_unique(
            where={
                'id': 'bacdaibgfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MobileNetworksWhereUniqueInput,
        include: Optional[types.MobileNetworksInclude] = None
    ) -> _PrismaModelT:
        """Find a unique MobileNetworks record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            MobileNetworks filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MobileNetworks model

        Returns
        -------
        prisma.models.MobileNetworks
            The found MobileNetworks record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mobilenetworks = await MobileNetworks.prisma().find_unique_or_raise(
            where={
                'id': 'dchgibach',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MobileNetworksWhereInput] = None,
        cursor: Optional[types.MobileNetworksWhereUniqueInput] = None,
        include: Optional[types.MobileNetworksInclude] = None,
        order: Optional[Union[types.MobileNetworksOrderByInput, List[types.MobileNetworksOrderByInput]]] = None,
        distinct: Optional[List[types.MobileNetworksScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple MobileNetworks records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of MobileNetworks records returned
        skip
            Ignore the first N results
        where
            MobileNetworks filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MobileNetworks model
        order
            Order the returned MobileNetworks records by any field
        distinct
            Filter MobileNetworks records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.MobileNetworks]
            The list of all MobileNetworks records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 MobileNetworks records
        mobilenetworks = await MobileNetworks.prisma().find_many(take=10)

        # find the first 5 MobileNetworks records ordered by the mnc field
        mobilenetworks = await MobileNetworks.prisma().find_many(
            take=5,
            order={
                'mnc': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MobileNetworksWhereInput] = None,
        cursor: Optional[types.MobileNetworksWhereUniqueInput] = None,
        include: Optional[types.MobileNetworksInclude] = None,
        order: Optional[Union[types.MobileNetworksOrderByInput, List[types.MobileNetworksOrderByInput]]] = None,
        distinct: Optional[List[types.MobileNetworksScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single MobileNetworks record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MobileNetworks filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MobileNetworks model
        order
            Order the returned MobileNetworks records by any field
        distinct
            Filter MobileNetworks records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MobileNetworks
            The first MobileNetworks record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MobileNetworks record ordered by the network field
        mobilenetworks = await MobileNetworks.prisma().find_first(
            skip=1,
            order={
                'network': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MobileNetworksWhereInput] = None,
        cursor: Optional[types.MobileNetworksWhereUniqueInput] = None,
        include: Optional[types.MobileNetworksInclude] = None,
        order: Optional[Union[types.MobileNetworksOrderByInput, List[types.MobileNetworksOrderByInput]]] = None,
        distinct: Optional[List[types.MobileNetworksScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single MobileNetworks record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MobileNetworks filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MobileNetworks model
        order
            Order the returned MobileNetworks records by any field
        distinct
            Filter MobileNetworks records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MobileNetworks
            The first MobileNetworks record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MobileNetworks record ordered by the iso field
        mobilenetworks = await MobileNetworks.prisma().find_first_or_raise(
            skip=1,
            order={
                'iso': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MobileNetworksUpdateInput,
        where: types.MobileNetworksWhereUniqueInput,
        include: Optional[types.MobileNetworksInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single MobileNetworks record.

        Parameters
        ----------
        data
            MobileNetworks record data specifying what to update
        where
            MobileNetworks filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned MobileNetworks model

        Returns
        -------
        prisma.models.MobileNetworks
            The updated MobileNetworks record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        mobilenetworks = await MobileNetworks.prisma().update(
            where={
                'id': 'fchheijjc',
            },
            data={
                # data to update the MobileNetworks record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MobileNetworksWhereUniqueInput,
        data: types.MobileNetworksUpsertInput,
        include: Optional[types.MobileNetworksInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            MobileNetworks filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned MobileNetworks model

        Returns
        -------
        prisma.models.MobileNetworks
            The created or updated MobileNetworks record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mobilenetworks = await MobileNetworks.prisma().upsert(
            where={
                'id': 'cacjdfhejh',
            },
            data={
                'create': {
                    'id': 'cacjdfhejh',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MobileNetworksUpdateManyMutationInput,
        where: types.MobileNetworksWhereInput,
    ) -> int:
        """Update multiple MobileNetworks records

        Parameters
        ----------
        data
            MobileNetworks data to update the selected MobileNetworks records to
        where
            Filter to select the MobileNetworks records to update

        Returns
        -------
        int
            The total number of MobileNetworks records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all MobileNetworks records
        total = await MobileNetworks.prisma().update_many(
            data={
                'country': 'bdbifjhbbi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MobileNetworksWhereInput] = None,
        cursor: Optional[types.MobileNetworksWhereUniqueInput] = None,
    ) -> int:
        """Count the number of MobileNetworks records present in the database

        Parameters
        ----------
        select
            Select the MobileNetworks fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MobileNetworks filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MobileNetworksCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MobileNetworks.prisma().count()

        # results: prisma.types.MobileNetworksCountAggregateOutput
        results = await MobileNetworks.prisma().count(
            select={
                '_all': True,
                'countryCode': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MobileNetworksCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MobileNetworksWhereInput] = None,
        cursor: Optional[types.MobileNetworksWhereUniqueInput] = None,
    ) -> types.MobileNetworksCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MobileNetworksCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MobileNetworksWhereInput] = None,
        cursor: Optional[types.MobileNetworksWhereUniqueInput] = None,
    ) -> Union[int, types.MobileNetworksCountAggregateOutput]:
        """Count the number of MobileNetworks records present in the database

        Parameters
        ----------
        select
            Select the MobileNetworks fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MobileNetworks filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MobileNetworksCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MobileNetworks.prisma().count()

        # results: prisma.types.MobileNetworksCountAggregateOutput
        results = await MobileNetworks.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MobileNetworksCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MobileNetworksWhereInput] = None
    ) -> int:
        """Delete multiple MobileNetworks records.

        Parameters
        ----------
        where
            Optional MobileNetworks filter to find the records to be deleted

        Returns
        -------
        int
            The total number of MobileNetworks records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all MobileNetworks records
        total = await MobileNetworks.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MobileNetworksScalarFieldKeys'],
        *,
        where: Optional['types.MobileNetworksWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MobileNetworksAvgAggregateInput'] = None,
        sum: Optional['types.MobileNetworksSumAggregateInput'] = None,
        min: Optional['types.MobileNetworksMinAggregateInput'] = None,
        max: Optional['types.MobileNetworksMaxAggregateInput'] = None,
        having: Optional['types.MobileNetworksScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MobileNetworksCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MobileNetworksScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MobileNetworksScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MobileNetworksGroupByOutput']:
        """Group MobileNetworks records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar MobileNetworks fields to group records by
        where
            MobileNetworks filter to select records
        take
            Limit the maximum number of MobileNetworks records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MobileNetworksGroupByOutput]
            A list of dictionaries representing the MobileNetworks record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group MobileNetworks records by mcc values
        # and count how many records are in each group
        results = await MobileNetworks.prisma().group_by(
            ['mcc'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models